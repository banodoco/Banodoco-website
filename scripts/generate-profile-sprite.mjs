import fs from 'node:fs';
import path from 'node:path';
import sharp from 'sharp';

const repoRoot = process.cwd();
const picsDir = path.join(repoRoot, 'public', 'profile_pics');
const spriteOut = path.join(repoRoot, 'public', 'profile-sprite.jpg');
const manifestOut = path.join(
  repoRoot,
  'src',
  'components',
  'sections',
  'Ownership',
  'profilePicsManifest.ts',
);

// Sprite configuration
const TILE_SIZE = 96; // 2x for Retina displays (source is 48x48, upscaled)
const COLUMNS = 20;   // 20 columns in the sprite

function isJpg(filename) {
  return filename.toLowerCase().endsWith('.jpg');
}

async function main() {
  if (!fs.existsSync(picsDir)) {
    console.error(`[sprite] Missing directory: ${picsDir}`);
    process.exit(1);
  }

  // Get all profile pic files, sorted alphabetically
  const files = fs
    .readdirSync(picsDir)
    .filter(isJpg)
    .sort((a, b) => a.localeCompare(b));

  const ids = files.map((f) => f.replace(/\.jpg$/i, '')).filter(Boolean);
  const count = files.length;
  const rows = Math.ceil(count / COLUMNS);

  console.log(`[sprite] Found ${count} profile pics`);
  console.log(`[sprite] Creating ${COLUMNS}x${rows} sprite (${COLUMNS * TILE_SIZE}x${rows * TILE_SIZE}px)`);

  // Create composite operations for sharp
  const composites = await Promise.all(
    files.map(async (file, index) => {
      const col = index % COLUMNS;
      const row = Math.floor(index / COLUMNS);
      const filePath = path.join(picsDir, file);
      
      // Read and ensure image is exactly TILE_SIZE x TILE_SIZE
      const buffer = await sharp(filePath)
        .resize(TILE_SIZE, TILE_SIZE, { fit: 'cover' })
        .toBuffer();

      return {
        input: buffer,
        left: col * TILE_SIZE,
        top: row * TILE_SIZE,
      };
    })
  );

  // Create the sprite image
  const spriteWidth = COLUMNS * TILE_SIZE;
  const spriteHeight = rows * TILE_SIZE;

  await sharp({
    create: {
      width: spriteWidth,
      height: spriteHeight,
      channels: 3,
      background: { r: 26, g: 22, b: 20 }, // Match section background #1a1614
    },
  })
    .composite(composites)
    .jpeg({ quality: 85 })
    .toFile(spriteOut);

  console.log(`[sprite] Wrote sprite to ${path.relative(repoRoot, spriteOut)}`);

  // Generate the manifest with sprite position data
  const spriteData = ids.map((id, index) => ({
    id,
    col: index % COLUMNS,
    row: Math.floor(index / COLUMNS),
  }));

  const manifestContent = `// This file is auto-generated by scripts/generate-profile-sprite.mjs
// Do not edit by hand.

/** Sprite configuration */
export const SPRITE_CONFIG = {
  /** Path to the sprite image */
  src: '/profile-sprite.jpg',
  /** Number of columns in the sprite grid */
  columns: ${COLUMNS},
  /** Number of rows in the sprite grid */
  rows: ${rows},
  /** Total number of profile pics */
  count: ${count},
} as const;

/** Profile pic data with sprite positions */
export const PROFILE_PICS = ${JSON.stringify(spriteData, null, 2)} as const;

/** Just the IDs for backward compatibility */
export const PROFILE_PIC_IDS = PROFILE_PICS.map(p => p.id);

export type ProfilePicId = (typeof PROFILE_PICS)[number]['id'];
`;

  fs.mkdirSync(path.dirname(manifestOut), { recursive: true });
  fs.writeFileSync(manifestOut, manifestContent, 'utf8');

  console.log(`[sprite] Wrote manifest to ${path.relative(repoRoot, manifestOut)}`);
  console.log(`[sprite] Done!`);
}

main().catch((err) => {
  console.error('[sprite] Error:', err);
  process.exit(1);
});

